
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Code Injection Semantics</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pyside.css" />
    <link rel="next" title="User Defined Type Conversion" href="typesystem_converters.html" />
    <link rel="prev" title="Modifying Arguments" href="typesystem_arguments.html" /> 
  </head><body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="_static/pysidelogo.png"/></a></div>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li class="right" >
          <a href="typesystem_converters.html" title="User Defined Type Conversion"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="typesystem_arguments.html" title="Modifying Arguments"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Shiboken  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="typesystem.html" accesskey="U">Type System Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Code Injection Semantics</a></li> 
      </ul>
    </div>
    </div>
</div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="code-injection-semantics">
<span id="codeinjectionsemantics"></span><h1>Code Injection Semantics</h1>
<p><a class="reference internal" href="shibokengenerator.html"><span class="doc">API Extractor</span></a> provides the
<a class="reference internal" href="typesystem_manipulating_objects.html#inject-code"><span class="std std-ref">inject-code</span></a> tag
allowing the user to put custom written code to on specific locations of the generated code.
Yet this is only part of what is needed to generate proper binding code, where the custom code
should be written to depends upon the technology used on the generated binding code.</p>
<p>This is the <code class="docutils literal notranslate"><span class="pre">inject-code</span></code> tag options that matters to Shiboken.</p>
<blockquote>
<div><div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;inject-code</span> <span class="na">class=</span><span class="s">&quot;native | target&quot;</span> <span class="na">position=</span><span class="s">&quot;beginning | end&quot;</span><span class="nt">&gt;</span>
    // custom code
<span class="nt">&lt;/inject-code&gt;</span>
</pre></div>
</div>
</div></blockquote>
<section id="inject-code-tag">
<h2>inject-code tag</h2>
<p>The following table describes the semantics of <code class="docutils literal notranslate"><span class="pre">inject-code</span></code> tag as used on
Shiboken. The <code class="docutils literal notranslate"><span class="pre">class</span></code> attribute specifies whether to code is injected
into the <strong>C++ Wrapper</strong> or the <strong>Python Wrapper</strong> (see
<a class="reference internal" href="typesystem_codegeneration.html#codegenerationterminology"><span class="std std-ref">Code Generation Terminology</span></a>).
The <code class="docutils literal notranslate"><span class="pre">position</span></code> attribute specifies the location of the custom code in the
function.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parent Tag</p></th>
<th class="head"><p>Class</p></th>
<th class="head"><p>Position</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="4"><p>value-type,
object-type</p></td>
<td rowspan="2"><p>native</p></td>
<td><p>beginning</p></td>
<td><p>Write to the beginning of a class wrapper <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file, right
after the <code class="docutils literal notranslate"><span class="pre">#include</span></code> clauses. A common use would be to write
prototypes for custom functions whose definitions are put on a
<code class="docutils literal notranslate"><span class="pre">native/end</span></code> code injection.</p></td>
</tr>
<tr class="row-odd"><td><p>end</p></td>
<td><p>Write to the end of a class wrapper <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file. Could be
used to write custom/helper functions definitions for
prototypes declared on <code class="docutils literal notranslate"><span class="pre">native/beginning</span></code>.</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>target</p></td>
<td><p>beginning</p></td>
<td><p>Put custom code on the beginning of the wrapper initializer
function (<code class="docutils literal notranslate"><span class="pre">init_CLASS(PyObject</span> <span class="pre">*module)</span></code>). This could be
used to manipulate the <code class="docutils literal notranslate"><span class="pre">PyCLASS_Type</span></code> structure before
registering it on Python.</p></td>
</tr>
<tr class="row-odd"><td><p>end</p></td>
<td><p>Write the given custom code at the end of the class wrapper
initializer function (<code class="docutils literal notranslate"><span class="pre">init_CLASS(PyObject</span> <span class="pre">*module)</span></code>). The
code here will be executed after all the wrapped class
components have been initialized.</p></td>
</tr>
<tr class="row-even"><td rowspan="7"><p>modify-function</p></td>
<td rowspan="2"><p>native</p></td>
<td><p>beginning</p></td>
<td><p>Code here is put on the virtual method override of a C++
wrapper class (the one responsible for passing C++ calls to a
Python override, if there is any), right after the C++
arguments have been converted but before the Python call.</p></td>
</tr>
<tr class="row-odd"><td><p>end</p></td>
<td><p>This code injection is put in a virtual method override on the
C++ wrapper class, after the call to Python and before
dereferencing the Python method and tuple of arguments.</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>target</p></td>
<td><p>beginning</p></td>
<td><p>This code is injected on the Python method wrapper
(<code class="docutils literal notranslate"><span class="pre">PyCLASS_METHOD(...)</span></code>), right after the decisor have found
which signature to call and also after the conversion of the
arguments to be used, but before the actual call.</p></td>
</tr>
<tr class="row-odd"><td><p>end</p></td>
<td><p>This code is injected on the Python method wrapper
(<code class="docutils literal notranslate"><span class="pre">PyCLASS_METHOD(...)</span></code>), right after the C++ method call,
but still inside the scope created by the overload for each
signature.</p></td>
</tr>
<tr class="row-even"><td rowspan="3"><p>shell</p></td>
<td><p>declaration</p></td>
<td><p>Used only for virtual functions. This code is injected at the
top.</p></td>
</tr>
<tr class="row-odd"><td><p>beginning</p></td>
<td><p>Used only for virtual functions. The code is injected when the
function does not has a Python implementation, then the code
is inserted before c++ call</p></td>
</tr>
<tr class="row-even"><td><p>end</p></td>
<td><p>Same as above, but the code is inserted after c++ call</p></td>
</tr>
<tr class="row-odd"><td rowspan="5"><p>typesystem</p></td>
<td rowspan="2"><p>native</p></td>
<td><p>beginning</p></td>
<td><p>Write code to the beginning of the module <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file, right
after the <code class="docutils literal notranslate"><span class="pre">#include</span></code> clauses. This position has a similar
purpose as the <code class="docutils literal notranslate"><span class="pre">native/beginning</span></code> position on a wrapper
class <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file, namely write function prototypes, but not
restricted to this use.</p></td>
</tr>
<tr class="row-even"><td><p>end</p></td>
<td><p>Write code to the end of the module <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file. Usually
implementations for function prototypes inserted at the
beginning of the file with a <code class="docutils literal notranslate"><span class="pre">native/beginning</span></code> code
injection.</p></td>
</tr>
<tr class="row-odd"><td rowspan="3"><p>target</p></td>
<td><p>beginning</p></td>
<td><p>Insert code at the start of the module initialization function
(<code class="docutils literal notranslate"><span class="pre">initMODULENAME()</span></code>), before the calling <code class="docutils literal notranslate"><span class="pre">Py_InitModule</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>end</p></td>
<td><p>Insert code at the end of the module initialization function
(<code class="docutils literal notranslate"><span class="pre">initMODULENAME()</span></code>), but before the checking that emits a
fatal error in case of problems importing the module.</p></td>
</tr>
<tr class="row-odd"><td><p>declaration</p></td>
<td><p>Insert code into module header.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="anatomy-of-code-injection">
<h2>Anatomy of Code Injection</h2>
<p>To make things clear let’s use a simplified example of generated wrapper code
and the places where each kind of code injection goes.</p>
<p>Below is the example C++ class for whom wrapper code will be generated.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">InjectCode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">InjectCode</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="nf">overloadedMethod</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="nf">overloadedMethod</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">virtualMethod</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>From the C++ class, Shiboken will generate a <code class="docutils literal notranslate"><span class="pre">injectcode_wrapper.cpp</span></code> file
with the binding code. The next section will use a simplified version of the
generated wrapper code with the injection spots marked with comments.</p>
<section id="noteworthy-cases">
<h3>Noteworthy Cases</h3>
<p>The type system description system gives the binding developer a lot of
flexibility, which is power, which comes with responsibility. Some modifications
to the wrapped API will not be complete without some code injection.</p>
<section id="removing-arguments-and-setting-a-default-values-for-them">
<h4>Removing arguments and setting a default values for them</h4>
<p>A simple case is when a function have one argument removed, as when the C++
method <code class="docutils literal notranslate"><span class="pre">METHOD(ARG)</span></code> is modified to be used from Python as <code class="docutils literal notranslate"><span class="pre">METHOD()</span></code>;
of course the binding developer must provide some guidelines to the generator
on what to do to call it. The most common solution is to remove the argument and
set a default value for it at the same time, so the original C++ method could be
called without problems.</p>
</section>
<section id="removing-arguments-and-calling-the-method-with-your-own-hands">
<h4>Removing arguments and calling the method with your own hands</h4>
<p>If the argument is removed and no default value is provided, the generator will
not write any call to the method and expect the <code class="docutils literal notranslate"><span class="pre">modify-function</span> <span class="pre">-</span> <span class="pre">target/beginning</span></code>
code injection to call the original C++ method on its own terms. If even this
custom code is not provided the generator will put an <code class="docutils literal notranslate"><span class="pre">#error</span></code> clause to
prevent compilation of erroneous binding code.</p>
</section>
<section id="calling-the-method-with-your-own-hands-always">
<h4>Calling the method with your own hands always!</h4>
<p>If your custom code to be injected contains a call to the wrapped C++ method,
it surely means that you don’t want the generator to write another call to the
same method. As expected Shiboken will detect the user written call on the code
injection and will not write its own call, but for this to work properly the
binding developer must use the template variable <code class="docutils literal notranslate"><span class="pre">%FUNCTION_NAME</span></code> instead
of writing the actual name of the wrapped method/function.</p>
<p>In other words, use</p>
<blockquote>
<div><div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;inject-code</span> <span class="na">class=</span><span class="s">&quot;target&quot;</span> <span class="na">position=</span><span class="s">&quot;beginning | end&quot;</span><span class="nt">&gt;</span>
    %CPPSELF.originalMethodName();
<span class="nt">&lt;/inject-code&gt;</span>
</pre></div>
</div>
</div></blockquote>
<p>instead of</p>
<blockquote>
<div><div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;inject-code</span> <span class="na">class=</span><span class="s">&quot;target&quot;</span> <span class="na">position=</span><span class="s">&quot;beginning | end&quot;</span><span class="nt">&gt;</span>
   %CPPSELF.%FUNCTION_NAME();
<span class="nt">&lt;/inject-code&gt;</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
</section>
<section id="code-injection-for-functions-methods">
<h2>Code Injection for Functions/Methods</h2>
<section id="on-the-native-side">
<span id="codeinjecting-method-native"></span><h3>On The Native Side</h3>
<p>Notice that this is only used when there is a C++ wrapper, i.e. the wrapped
class is polymorphic.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">InjectCodeWrapper::virtualMethod</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">PyObject</span><span class="o">*</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BindingManager</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">getOverride</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;virtualMethod&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">py_override</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">InjectCode</span><span class="o">::</span><span class="n">virtualMethod</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">(...</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">converted</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">Python</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// INJECT-CODE: &lt;modify-function&gt;&lt;inject-code class=&quot;native&quot; position=&quot;beginning&quot;&gt;</span>
<span class="w">    </span><span class="c1">// Uses: pre method call custom code, modify the argument before the</span>
<span class="w">    </span><span class="c1">// Python call.</span>

<span class="w">    </span><span class="p">(...</span><span class="w"> </span><span class="n">Python</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">goes</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// INJECT-CODE: &lt;modify-function&gt;&lt;inject-code class=&quot;native&quot; position=&quot;end&quot;&gt;</span>
<span class="w">    </span><span class="c1">// Uses: post method call custom code, modify the result before delivering</span>
<span class="w">    </span><span class="c1">// it to C++ caller.</span>

<span class="w">    </span><span class="p">(...</span><span class="w"> </span><span class="n">Python</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">dereferenced</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Shiboken</span><span class="o">::</span><span class="n">Converter</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">toCpp</span><span class="p">(</span><span class="n">method_result</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="on-the-target-side">
<h3>On The Target Side</h3>
<p>All the overloads of a method from C++ are gathered together on a single Python
method that uses an overload decisor to call the correct C++ method based on the
arguments passed by the Python call. Each overloaded method signature has its
own <code class="docutils literal notranslate"><span class="pre">beginning</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> code injections.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="o">*</span><span class="w"></span>
<span class="nf">PyInjectCode_overloadedMethod</span><span class="p">(</span><span class="n">PyObject</span><span class="o">*</span><span class="w"> </span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="o">*</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">PyObject</span><span class="o">*</span><span class="w"> </span><span class="n">py_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyFloat_Check</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">cpp_arg0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Shiboken</span><span class="o">::</span><span class="n">Converter</span><span class="o">&lt;</span><span class="kt">double</span><span class="w"> </span><span class="o">&gt;::</span><span class="n">toCpp</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// INJECT-CODE: &lt;modify-function&gt;&lt;inject-code class=&quot;target&quot; position=&quot;beginning&quot;&gt;</span>
<span class="w">        </span><span class="c1">// Uses: pre method call custom code.</span>

<span class="w">        </span><span class="n">py_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Shiboken</span><span class="o">::</span><span class="n">Converter</span><span class="o">&lt;</span><span class="kt">double</span><span class="w"> </span><span class="o">&gt;::</span><span class="n">toPython</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">PyInjectCode_cptr</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">InjectCode</span><span class="o">::</span><span class="n">overloadedMethod</span><span class="p">(</span><span class="n">cpp_arg0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// INJECT-CODE: &lt;modify-function&gt;&lt;inject-code class=&quot;target&quot; position=&quot;end&quot;&gt;</span>
<span class="w">        </span><span class="c1">// Uses: post method call custom code.</span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyNumber_Check</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">(...</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">overload</span><span class="w"> </span><span class="n">calling</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">goto</span><span class="w"> </span><span class="n">PyInjectCode_overloadedMethod_TypeError</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyErr_Occurred</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">py_result</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">py_result</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="nl">PyInjectCode_overloadedMethod_TypeError</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&#39;overloadedMethod()&#39; called with wrong parameters.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="code-injection-for-wrapped-classes">
<span id="codeinjecting-classes"></span><h2>Code Injection for Wrapped Classes</h2>
<section id="codeinjecting-classes-native">
<span id="id1"></span><h3>On The Native Side</h3>
<p>Those injections go in the body of the <code class="docutils literal notranslate"><span class="pre">CLASSNAME_wrapper.cpp</span></code> file for the
wrapped class.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Start of ``CLASSNAME_wrapper.cpp``</span>
<span class="cp">#define protected public</span>
<span class="c1">// default includes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;shiboken.h&gt;</span><span class="cp"></span>
<span class="p">(...)</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;injectcode_wrapper.h&quot;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">Shiboken</span><span class="p">;</span><span class="w"></span>

<span class="c1">// INJECT-CODE: &lt;value/object-type&gt;&lt;inject-code class=&quot;native&quot; position=&quot;beginning&quot;&gt;</span>
<span class="c1">// Uses: prototype declarations</span>

<span class="p">(...</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="w"> </span><span class="n">wrapper</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">methods</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>

<span class="p">(...</span><span class="w"> </span><span class="n">Python</span><span class="w"> </span><span class="n">wrapper</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>

<span class="n">PyAPI_FUNC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="n">init_injectcode</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="k">module</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(...)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">(...)</span><span class="w"></span>

<span class="c1">// INJECT-CODE: &lt;value/object-type&gt;&lt;inject-code class=&quot;native&quot; position=&quot;end&quot;&gt;</span>
<span class="c1">// Uses: definition of functions prototyped at ``native/beginning``.</span>

<span class="c1">// End of ``CLASSNAME_wrapper.cpp``</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="codeinjecting-classes-target">
<span id="id2"></span><h3>On The Target Side</h3>
<p>Code injections to the class Python initialization function.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Start of ``CLASSNAME_wrapper.cpp``</span>

<span class="p">(...)</span><span class="w"></span>

<span class="n">PyAPI_FUNC</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="n">init_injectcode</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="k">module</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// INJECT-CODE: &lt;value/object-type&gt;&lt;inject-code class=&quot;target&quot; position=&quot;beginning&quot;&gt;</span>
<span class="w">    </span><span class="c1">// Uses: Alter something in the PyInjectCode_Type (tp_flags value for example)</span>
<span class="w">    </span><span class="c1">// before registering it.</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyInjectCode_Type</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyInjectCode_Type</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">PyModule_AddObject</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;InjectCode&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">PyInjectCode_Type</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// INJECT-CODE: &lt;value/object-type&gt;&lt;inject-code class=&quot;target&quot; position=&quot;end&quot;&gt;</span>
<span class="w">    </span><span class="c1">// Uses: do something right after the class is registered, like set some static</span>
<span class="w">    </span><span class="c1">// variable injected on this same file elsewhere.</span>
<span class="p">}</span><span class="w"></span>

<span class="p">(...)</span><span class="w"></span>

<span class="c1">// End of ``CLASSNAME_wrapper.cpp``</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="code-injection-for-modules">
<h2>Code Injection for Modules</h2>
<p>The C++ libraries are wrapped as Python modules, a collection of classes,
functions, enums and namespaces. Shiboken creates wrapper files for all of
them and also one extra <code class="docutils literal notranslate"><span class="pre">MODULENAME_module_wrapper.cpp</span></code> to register the whole
module. Code injection xml tags who have the <code class="docutils literal notranslate"><span class="pre">typesystem</span></code> tag as parent will
be put on this file.</p>
<section id="id3">
<h3>On The Native Side</h3>
<p>This works exactly as the class wrapper code injections <a class="reference internal" href="#codeinjecting-classes-native"><span class="std std-ref">On The Native Side</span></a>.</p>
</section>
<section id="id4">
<h3>On The Target Side</h3>
<p>This is very similar to class wrapper code injections <a class="reference internal" href="#codeinjecting-classes-target"><span class="std std-ref">On The Target Side</span></a>.
Notice that the inject code at <code class="docutils literal notranslate"><span class="pre">target/end</span></code> is inserted before the check for errors
to prevent bad custom code to pass unnoticed.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Start of ``MODULENAME_module_wrapper.cpp``</span>

<span class="p">(...)</span><span class="w"></span>
<span class="n">initMODULENAME</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// INJECT-CODE: &lt;typesystem&gt;&lt;inject-code class=&quot;target&quot; position=&quot;beginning&quot;&gt;</span>
<span class="w">    </span><span class="c1">// Uses: do something before the module is created.</span>

<span class="w">    </span><span class="n">PyObject</span><span class="o">*</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_InitModule</span><span class="p">(</span><span class="s">&quot;MODULENAME&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MODULENAME_methods</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">(...</span><span class="w"> </span><span class="n">initialization</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">wrapped</span><span class="w"> </span><span class="n">classes</span><span class="p">,</span><span class="w"> </span><span class="n">namespaces</span><span class="p">,</span><span class="w"> </span><span class="n">functions</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">enums</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// INJECT-CODE: &lt;typesystem&gt;&lt;inject-code class=&quot;target&quot; position=&quot;end&quot;&gt;</span>
<span class="w">    </span><span class="c1">// Uses: do something after the module is registered and initialized.</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyErr_Occurred</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="n">Py_FatalError</span><span class="p">(</span><span class="s">&quot;can&#39;t initialize module sample&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">(...)</span><span class="w"></span>

<span class="c1">// Start of ``MODULENAME_module_wrapper.cpp``</span>
</pre></div>
</div>
</div></blockquote>
<p>In addition, code can be injected into the module header by specifying <code class="docutils literal notranslate"><span class="pre">target</span></code>
and <code class="docutils literal notranslate"><span class="pre">declaration</span></code>. This is useful for type definitions.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.qt.io/"><img src="_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>